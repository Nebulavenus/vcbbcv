(let :red '(255, 0, 0, 255))
(let :black '(0, 0, 0, 255))
(let :white '(255, 255, 255, 255))
(let :green '(0, 255, 0, 255))
(let :yellow '(255, 255, 0, 255))

(defclass Vec2
  (field x)
  (field y)

  (init (@x @y))

  (const zero (fn0 (Vec2 0.0 0.0)))

  (met copy ()
    (Vec2 @x @y))

  ; examine macroses to overload + for vec2
  (met add-val (val : num?)
    (inc! @x val)
    (inc! @y val))

  (met mul-val (val : num?)
    (mul! @x val)
    (mul! @y val))

  (met div-val (val : num?)
    (div! @x val)
    (div! @y val))

  (met add-vec (other-vec : (is? other-vec Vec2))
    (let [x y] other-vec)
    (inc! @x x)
    (inc! @y y))
  
  (met length ()
    (let xx (pow @x 2))
    (let yy (pow @y 2))
    (sqrt (+ xx yy)))
  
  (met normalize ()
    (let l (.length @self))
    (div! @x l)
    (div! @y l))
  
  (met neg ()
    (neg! @x)
    (neg! @y))

  (met split ()
    (arr @x @y)))

(defn wrap-around (vec : (is? vec Vec2)) ; todo: check for i32 or f32 in vec
  (let vr (.copy vec))
  (let (width height) (screen-size)) ; (f32 f32) returned
  (cond
    ((> [vr 'x] width)
      (= [vr 'x] 0.0))
    ((< [vr 'x] 0.0)
      (= [vr 'x] width))
    ((> [vr 'y] height)
      (= [vr 'y] 0.0))
    ((< [vr 'y] 0.0)
      (= [vr 'y] height)))
  (return vr))

(defclass Ship
  (const vis-height 28.0)
  (const vis-base 18.0)
  (const mov-speed 10.0)
  (const rot-speed 5.0)

  (field pos)
  (field rot)
  (field vel)

  (init ()
    (@reset))

  (met reset ()
    (= @pos (.zero Vec2))
    (= @rot 0.0)
    (= @vel (.zero Vec2)))

  ; passed dt and game variables are probably redundant and I should just use globals?
  (met update (dt, sst, game) ; delta time = dt, since start time = sst
    ; handle acceleration input & logic
    (let acc (.copy @vel))
    (.neg acc)
    (.div-val acc 10.0)
    (when (down? 'key:up)
      (let dir (Vec2 (sin @rot) (- (cos @rot))))
      (.div-val dir 3.0)
      (= acc dir))

    (.add-vec @vel acc)
    
    ; constrain max speed
    (let max-speed 5.0)
    (when (> (.length @vel) max-speed)
      (.normalize @vel)
      (.mul-val @vel max-speed))

    ; handle rotation input
    (when (down? 'key:right)
      (inc! @rot (* dt @rot-speed)))
    (when (down? 'key:left)
      (dec! @rot (* dt @rot-speed)))
    
    ; handle fire input
    (when (down? 'key:space)
      (let rot (Vec2 (sin @rot) (- (cos @rot))))

      (let vel (.copy rot))
      (.mul-val vel [Bullet 'speed]) ; ship rot dir by bullet's constant speed

      (let pos (.copy @pos))
      (.mul-val rot (/ @vis-height 2.0))
      (.add-vec pos rot)

      (let bullet (Bullet pos vel sst))
      (.add-bullet game bullet))

    ; simple movement
    (.add-vec @pos @vel)
    
    ; wrap around the screen
    (= @pos (wrap-around @pos)))

  (met draw ()
    (let [(x px) (y py)] @pos)
    (let ship-height-x (* (sin @rot) (/ @vis-height 2.0)))
    (let ship-height-y (* (cos @rot) (/ @vis-height 2.0)))
    (let ship-base-x (* (cos @rot) (/ @vis-base 2.0)))
    (let ship-base-y (* (sin @rot) (/ @vis-base 2.0)))
    (let v1 (Vec2
      (+ px ship-height-x) (- py ship-height-y)))
    (let v2 (Vec2
      (- (- px ship-base-x) ship-height-x)
      (+ (- py ship-base-y) ship-height-y)))
    (let v3 (Vec2
      (- (+ px ship-base-x) ship-height-x)
      (+ (+ py ship-base-y) ship-height-y)))
    (draw-triangle-lines
      (.split v1)
      (.split v2)
      (.split v3)
      5.0
      :green)))

(defclass Bullet
  (const speed 7.0)
  (const lifetime 1.5)
  (field pos)
  (field vel)
  (field shot-at)

  (init (@pos @vel @shot-at))

  (met ranout? (cur-t)
    (> (+ @shot-at @lifetime) cur-t))

  (met update (dt)
    (.add-vec @pos @vel))

  (met draw ()
    (let [x y] @pos)
    (draw-circle x y 2.0 :red)))

(defclass Asteroid
  (field rot-speed (rand -2.0 2.0))
  (field size (rand 20.0 80.0))
  (field sides (rand 3 7))

  (field pos)
  (field rot)
  (field vel)

  (init (@pos @vel)
    (= @rot 0.0))

  (met update (dt)
    (inc! @rot @rot-speed)
    (.add-vec @pos @vel)
    (= @pos (wrap-around @pos)))

  (met draw ()
    (let [x y] @pos)
    (draw-poly-lines x y @sides @size @rot 2.0 :yellow)))

(defclass Game
  (field bullets)
  (field asteroids) ; array of asteroid class

  (init ()
    ; init fields
    (= @bullets (arr))
    (= @asteroids (arr))

    ; by default spawn some asteroids
    (let (w h) (screen-size))
    (forn (_ 10)
      (let pos (Vec2 (flo (rand w)) (flo (rand h))))
      (let vel (Vec2 (rand -1.0 1.0) (rand -1.0 1.0)))
      (push! @asteroids (Asteroid pos vel))))

  (met add-bullet (bullet : (is? bullet Bullet))
    (push! @bullets bullet))

  (met update (dt, sst)
    ; kill all unrelevant entities
    (retain! (fn1 (.ranout? _ sst)) @bullets) ; _ is a bullet, just check fn1 in reference

    ; yielding spawn for asteroids

    ; update bullets logic
    (for bul in @bullets
      (.update bul dt))

    ; update asteroids logic
    (for ast in @asteroids
      (.update ast dt)))

  (met draw ()
    ; draw bullets
    (for bul in @bullets
      (.draw bul))

    ; draw asteroids
    (for ast in @asteroids
      (.draw ast))))

;  (met overlaps? (other-circle)
;    (let [x y r] other-circle)
;    (let rr (+ @r r))
;    (let dx (- @x x))
;    (let dy (- @y y))
;    (> (pow rr 2) (+ (pow dx 2) (pow dy 2))))

(def game (Game))
(def player-ship (Ship))

(defn engine:update (dt)
  (let sst (get-time)) ; time since start

  (.update game dt sst)
  (.update player-ship dt sst game))

(defn engine:draw ()
  (clear-background :black)
  (.draw game)
  (.draw player-ship)
  (draw-text "Hi" 30.0 30.0 30.0 :white))